import { Payment, AthleteSport } from '../types';

export interface PaymentMonth {
  month: string;
  monthLabel: string;
  payment: Payment | null;
  expectedAmount: number;
  status: 'paid' | 'pending' | 'overdue' | 'not_generated';
  isAutoGenerated?: boolean;
}

export const generatePaymentId = (): string => {
  return `payment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

export const formatMonth = (monthStr: string): string => {
  const [year, month] = monthStr.split('-');
  const date = new Date(parseInt(year), parseInt(month) - 1);
  return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
};

export const getCurrentMonth = (): string => {
  const now = new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
};

export const addMonthsToDate = (dateStr: string, months: number): string => {
  const date = new Date(dateStr + '-01');
  date.setMonth(date.getMonth() + months);
  return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
};

export const isMonthPast = (monthStr: string): boolean => {
  const monthDate = new Date(monthStr + '-01');
  const currentDate = new Date();
  currentDate.setDate(1); // Set to first day of current month for comparison
  return monthDate < currentDate;
};

export const isCurrentMonth = (monthStr: string): boolean => {
  return monthStr === getCurrentMonth();
};

export const generateAutomaticPayments = (sportData: AthleteSport): Payment[] => {
  const startDate = new Date(sportData.date_debut);
  const currentDate = new Date();
  const existingPayments = Object.values(sportData.paiements || {});
  const newPayments: Payment[] = [];
  
  // Generate payments from start date to current month
  const date = new Date(startDate);
  
  while (date <= currentDate) {
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    
    // Enhanced check to prevent duplicate payments
    const existingPayment = existingPayments.find(p => p.mois === monthKey);
    
    if (!existingPayment) {
      // Determine status based on month
      let status: 'paid' | 'pending' | 'overdue';
      
      if (isCurrentMonth(monthKey)) {
        status = 'pending';
      } else if (isMonthPast(monthKey)) {
        status = 'overdue';
      } else {
        status = 'pending';
      }
      
      const newPayment: Payment = {
        id: generatePaymentId(),
        mois: monthKey,
        montant: sportData.montant,
        date_paiement: '',
        status: status
      };
      
      newPayments.push(newPayment);
    } else {
      // Log existing payment (for debugging)
      console.log(`Payment already exists for ${monthKey}:`, existingPayment);
    }
    
    date.setMonth(date.getMonth() + 1);
  }
  
  return newPayments;
};

export const generateCompletePaymentHistory = (sportData: AthleteSport): PaymentMonth[] => {
  const startDate = new Date(sportData.date_debut);
  const currentDate = new Date();
  const existingPayments = Object.values(sportData.paiements || {});
  const allMonths: PaymentMonth[] = [];
  
  // Generate all months from start date to current date
  const date = new Date(startDate);
  
  while (date <= currentDate) {
    const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    const existingPayment = existingPayments.find(p => p.mois === monthKey);
    
    let status: 'paid' | 'pending' | 'overdue' | 'not_generated';
    
    if (existingPayment) {
      status = existingPayment.status;
    } else {
      // Auto-classify based on month
      if (isCurrentMonth(monthKey)) {
        status = 'pending';
      } else if (isMonthPast(monthKey)) {
        status = 'overdue';
      } else {
        status = 'not_generated';
      }
    }
    
    allMonths.push({
      month: monthKey,
      monthLabel: formatMonth(monthKey),
      payment: existingPayment || null,
      expectedAmount: sportData.montant,
      status: status,
      isAutoGenerated: !existingPayment
    });
    
    date.setMonth(date.getMonth() + 1);
  }
  
  return allMonths.reverse(); // Most recent first
};

export const createAdvancePayments = (
  sportData: AthleteSport, 
  startMonth: string, 
  numberOfMonths: number
): Payment[] => {
  const advancePayments: Payment[] = [];
  const existingPayments = Object.values(sportData.paiements || {});
  
  for (let i = 0; i < numberOfMonths; i++) {
    const monthKey = addMonthsToDate(startMonth, i);
    
    // Check if payment already exists for this month
    const existingPayment = existingPayments.find(p => p.mois === monthKey);
    
    if (existingPayment) {
      console.warn(`Skipping duplicate payment for ${monthKey}:`, existingPayment);
      continue; // Skip this month if payment already exists
    }
    
    const payment: Payment = {
      id: generatePaymentId(),
      mois: monthKey,
      montant: sportData.montant,
      date_paiement: new Date().toISOString().split('T')[0],
      status: 'paid'
    };
    
    advancePayments.push(payment);
  }
  
  return advancePayments;
};

export const updatePaymentStatuses = (payments: Record<string, Payment>): Record<string, Payment> => {
  const updatedPayments = { ...payments };
  
  Object.keys(updatedPayments).forEach(paymentId => {
    const payment = updatedPayments[paymentId];
    
    // Only update if not already paid
    if (payment.status !== 'paid') {
      if (isCurrentMonth(payment.mois)) {
        payment.status = 'pending';
      } else if (isMonthPast(payment.mois)) {
        payment.status = 'overdue';
      }
    }
  });
  
  return updatedPayments;
};